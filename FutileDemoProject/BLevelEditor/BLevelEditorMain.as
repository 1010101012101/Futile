package 
{
	import flash.display.Sprite;
	import flash.display.Graphics;
	import flash.events.KeyboardEvent;
	import flash.events.MouseEvent;
	import flash.geom.Point;
	import flash.ui.Keyboard;
	/**
	 * ...
	 * @author Matt Rix
	 */
	public class BLevelEditorMain extends Sprite
	{
		public static const POINT_SCALE:Number = 0.5;
		private var _polygons:Array = new Array();
		private var _polygonPoints = new Array();
		private var _currentPolygon:Sprite = null;
		private var _currentPolygonPoints = null;
		
		public function BLevelEditorMain() 
		{
			stage.addEventListener(MouseEvent.MOUSE_DOWN, onMouseDown);
			stage.addEventListener(KeyboardEvent.KEY_DOWN, onKeyDown);
		}
		
		private function convertPoint(point:Point):Point
		{
			return new Point(point.x * POINT_SCALE, (stage.stageHeight - point.y) * POINT_SCALE);
		}
		
		private function onKeyDown(e:KeyboardEvent):void 
		{
			if (e.keyCode == Keyboard.SPACE || e.keyCode == Keyboard.ENTER || e.keyCode == Keyboard.NUMPAD_ENTER) //finish
			{
				if (_currentPolygon == null) return; //we have no polygon to finish
				
				_currentPolygon.graphics.lineTo(_currentPolygonPoints[0].x, _currentPolygonPoints[0].y);
				_currentPolygon.alpha = 1.0;
				
				_polygons.push(_currentPolygon);
				_polygonPoints.push(_currentPolygonPoints);
		
				_currentPolygon = null;
				_currentPolygonPoints = null;
			}
			else if (e.keyCode == Keyboard.DELETE) //destroy
			{
				if (_currentPolygon == null && _polygons.length > 0)
				{
					var polygon:Sprite = _polygons.pop();
					_polygonPoints.pop();
					
					removeChild(polygon);
				}
				else 
				{
					removeChild(_currentPolygon);
					_currentPolygon = null;
					_currentPolygonPoints = null;
				}
			}
			else if (e.keyCode == Keyboard.E) //export
			{
				var output:String = "//Generated by the BLevelEditor\r\n\n";
				
				output += "List<Vector2[]> polygons = new List<Vector2[]>();\r\n\n";
				
				for (var p:int = 0; p < _polygons.length; p++)
				{
					var polygon:Sprite = _polygons[p];
					var points:Array = _polygonPoints[p];
					
					if (p == 0)
					{
						output += "Vector2[] ";
					}
					output += "vertices = new Vector2[" + points.length + "];\n"
					for (var c:int = 0; c < points.length; c++)
					{
						var convertedPoint:Point = convertPoint(points[c]);
						output += "vertices[" + c + "] = new Vector2("+convertedPoint.x+"f,"+convertedPoint.y+"f);\n";
					}
					output += "polygons.Add(vertices);\n";
					
					output += "\r\n\n";
				}

				trace(output);
				
			}
		}
		
		private function onMouseDown(e:MouseEvent):void 
		{
			var tapX = this.mouseX;
			var tapY = this.mouseY;
			
			if(_currentPolygon == null)
			{
				addChild(_currentPolygon = new Sprite());
				_currentPolygon.graphics.beginFill(0xFF9966, 0.5);
				_currentPolygon.graphics.lineStyle(4, 0x663300, 1);
				_currentPolygon.graphics.moveTo(tapX, tapY);
				_currentPolygon.alpha = 0.75;
				_currentPolygonPoints = new Array();
			}
			else 
			{
				_currentPolygon.graphics.lineTo(tapX, tapY);
			}
			
			_currentPolygonPoints.push(new Point(tapX, tapY));
		}
		
		
	}

}